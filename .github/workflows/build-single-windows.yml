name: Build Single Windows App

on:
  workflow_dispatch:
    inputs:
      url:
        description: 'Web URL to package'
        required: true
        default: 'http://34.96.239.88:8989/'
        type: string
      name:
        description: 'Application name'
        required: true
        default: '欧联'
        type: string
      icon:
        description: 'Icon URL (jpg/png/ico). If not .ico, will auto-convert'
        required: false
        default: ''
        type: string
      installer:
        description: 'Installer type: nsis (recommended) or msi (requires WiX; may fail if light.exe fails)'
        required: true
        default: 'nsis'
        type: choice
        options:
          - nsis
          - msi

jobs:
  build-windows:
    name: Build Windows App
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable-x86_64-msvc
        profile: minimal
        override: true
        target: x86_64-pc-windows-msvc

    - name: Install dependencies
      run: npm install

    - name: Build CLI
      run: npm run cli:build

    - name: Convert icon to .ico (if needed)
      shell: pwsh
      if: inputs.icon != ''
      run: |
        $iconUrl = "${{ inputs.icon }}"
        if ($iconUrl.ToLower().EndsWith(".ico")) {
          Write-Host "Icon is already .ico, using directly"
          echo "ICON_PATH=$iconUrl" >> $env:GITHUB_ENV
        } else {
          Write-Host "Converting icon to .ico..."
          $tempDir = "$env:RUNNER_TEMP\pake-icon"
          New-Item -ItemType Directory -Force -Path $tempDir | Out-Null
          $inputFile = "$tempDir\icon_input"
          $outputFile = "$tempDir\icon.ico"
          
          Invoke-WebRequest -Uri $iconUrl -OutFile $inputFile -UseBasicParsing
          python -m pip install Pillow --quiet
          python -c "from PIL import Image; img = Image.open(r'$inputFile').convert('RGBA').resize((256, 256)); img.save(r'$outputFile', format='ICO')"
          
          echo "ICON_PATH=$outputFile" >> $env:GITHUB_ENV
          Write-Host "Icon converted: $outputFile"
        }

    - name: Build Windows app
      shell: pwsh
      run: |
        # 设置 UTF-8 编码，避免 WiX 处理中文文件名时失败
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        [Console]::InputEncoding = [System.Text.Encoding]::UTF8
        $env:PYTHONIOENCODING = "utf-8"
        cmd /c chcp 65001 > $null
        
        # 设置 installer 类型环境变量
        $installerType = "${{ inputs.installer }}".ToLower()
        $env:PAKE_WINDOWS_INSTALLER = $installerType
        Write-Host "Installer type: $installerType"
        Write-Host "PAKE_WINDOWS_INSTALLER=$env:PAKE_WINDOWS_INSTALLER"
        
        $args = @("${{ inputs.url }}", "--name", "${{ inputs.name }}", "--target", "win")
        if ("${{ inputs.icon }}" -ne "" -and $env:ICON_PATH) {
          $args += @("--icon", $env:ICON_PATH)
        }
        Write-Host "Running: node cli.js $($args -join ' ')"
        
        # 两段式构建：
        # - 如果用户选 msi：先尝试 msi，失败后自动再尝试 nsis（确保一定有可安装的 setup.exe）
        # - 如果用户选 nsis：直接 nsis
        $requestedInstaller = "${{ inputs.installer }}".ToLower()
        $attempts = @()
        if ($requestedInstaller -eq "msi") {
          $attempts = @("msi", "nsis")
        } else {
          $attempts = @("nsis")
        }

        $buildSuccess = $false
        foreach ($attempt in $attempts) {
          Write-Host "==== Build attempt: $attempt ===="
          $env:PAKE_WINDOWS_INSTALLER = $attempt
          Write-Host "设置环境变量 PAKE_WINDOWS_INSTALLER=$env:PAKE_WINDOWS_INSTALLER"
          try {
            # 使用 & 调用，确保环境变量传递
            $env:PAKE_WINDOWS_INSTALLER = $attempt
            & node cli.js $args
            if ($LASTEXITCODE -eq 0) {
              $buildSuccess = $true
            }
          } catch {
            Write-Host "Build attempt failed: $attempt"
          }

          # 如果本次已经产出了安装包，就不再继续下一次尝试
          $msiFiles = Get-ChildItem -Recurse -Filter "*.msi" -ErrorAction SilentlyContinue | Where-Object { $_.DirectoryName -like "*\bundle\msi\*" }
          $nsisFiles = Get-ChildItem -Recurse -Filter "*setup.exe" -ErrorAction SilentlyContinue | Where-Object { $_.DirectoryName -like "*\bundle\nsis\*" -and $_.Name -like "*setup*" }
          if ($msiFiles -or $nsisFiles) {
            break
          }
        }
        
        # 检查是否生成了安装包（MSI 或 NSIS setup.exe）
        # 注意：不要查找裸 exe（target/release/*.exe），因为它缺少依赖，双击没反应
        $outputFound = $false
        $installerType = "${{ inputs.installer }}".ToLower()
        
        # 根据用户选择的类型查找安装包
        if ($installerType -eq "msi") {
          # 查找 MSI 安装包
          $msiFiles = Get-ChildItem -Recurse -Filter "*.msi" -ErrorAction SilentlyContinue | 
            Where-Object { $_.DirectoryName -like "*\bundle\msi\*" }
          if ($msiFiles) {
            Write-Host "Found MSI installer:"
            $msiFiles | ForEach-Object { Write-Host "  $($_.FullName)" }
            $finalMsiName = "${{ inputs.name }}.msi"
            $msiFiles | Select-Object -First 1 | ForEach-Object { Copy-Item $_.FullName -Destination $finalMsiName -Force }
            Write-Host "MSI installer copied to: $finalMsiName"
            $outputFound = $true
          } else {
            Write-Host "MSI not found, trying NSIS as fallback..."
            # MSI 失败时，自动回退到 NSIS
            $nsisFiles = Get-ChildItem -Recurse -Filter "*setup.exe" -ErrorAction SilentlyContinue | 
              Where-Object { $_.DirectoryName -like "*\bundle\nsis\*" -and $_.Name -like "*setup*" }
            if ($nsisFiles) {
              Write-Host "Found NSIS installer (fallback):"
              $nsisFiles | ForEach-Object { Write-Host "  $($_.FullName)" }
              $finalNsisName = "${{ inputs.name }}-setup.exe"
              $nsisFiles | Select-Object -First 1 | ForEach-Object { Copy-Item $_.FullName -Destination $finalNsisName -Force }
              Write-Host "NSIS installer copied to: $finalNsisName"
              $outputFound = $true
            }
          }
        } else {
          # 查找 NSIS 安装包（*-setup.exe）
          $nsisFiles = Get-ChildItem -Recurse -Filter "*setup.exe" -ErrorAction SilentlyContinue | 
            Where-Object { $_.DirectoryName -like "*\bundle\nsis\*" -and $_.Name -like "*setup*" }
          if ($nsisFiles) {
            Write-Host "Found NSIS installer:"
            $nsisFiles | ForEach-Object { Write-Host "  $($_.FullName)" }
            $finalNsisName = "${{ inputs.name }}-setup.exe"
            $nsisFiles | Select-Object -First 1 | ForEach-Object { Copy-Item $_.FullName -Destination $finalNsisName -Force }
            Write-Host "NSIS installer copied to: $finalNsisName"
            $outputFound = $true
          }
        }
        
        # 如果找到了输出文件，即使构建命令失败也视为成功
        if ($outputFound) {
          Write-Host "Build output found. Treating as success despite build command exit code."
          exit 0
        } elseif (-not $buildSuccess) {
          Write-Host "Build failed and no output files found."
          throw "Build failed and no output files found"
        }
      env:
        CI: true
        PYTHONIOENCODING: utf-8

    - name: Upload Windows installer
      uses: actions/upload-artifact@v4
      with:
        name: windows-installer
        path: |
          *.msi
          *.exe
        retention-days: 30
