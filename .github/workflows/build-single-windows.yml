name: Build Single Windows App

on:
  workflow_dispatch:
    inputs:
      url:
        description: 'Web URL to package'
        required: true
        default: 'http://34.96.239.88:8989/'
        type: string
      name:
        description: 'Application name'
        required: true
        default: '欧联'
        type: string
      icon:
        description: 'Icon URL (jpg/png/ico). If not .ico, will auto-convert'
        required: false
        default: ''
        type: string

jobs:
  build-windows:
    name: Build Windows App
    runs-on: windows-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable-x86_64-msvc
        profile: minimal
        override: true
        target: x86_64-pc-windows-msvc

    - name: Install dependencies
      run: npm install

    - name: Build CLI
      run: npm run cli:build

    - name: Convert icon to .ico (if needed)
      shell: pwsh
      if: inputs.icon != ''
      run: |
        $iconUrl = "${{ inputs.icon }}"
        if ($iconUrl.ToLower().EndsWith(".ico")) {
          Write-Host "Icon is already .ico, using directly"
          echo "ICON_PATH=$iconUrl" >> $env:GITHUB_ENV
        } else {
          Write-Host "Converting icon to .ico..."
          $tempDir = "$env:RUNNER_TEMP\pake-icon"
          New-Item -ItemType Directory -Force -Path $tempDir | Out-Null
          $inputFile = "$tempDir\icon_input"
          $outputFile = "$tempDir\icon.ico"
          
          Invoke-WebRequest -Uri $iconUrl -OutFile $inputFile -UseBasicParsing
          python -m pip install Pillow --quiet
          python -c "from PIL import Image; img = Image.open(r'$inputFile').convert('RGBA').resize((256, 256)); img.save(r'$outputFile', format='ICO')"
          
          echo "ICON_PATH=$outputFile" >> $env:GITHUB_ENV
          Write-Host "Icon converted: $outputFile"
        }

    - name: Build Windows app
      shell: pwsh
      run: |
        # 设置 UTF-8 编码，避免 WiX 处理中文文件名时失败
        [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
        [Console]::InputEncoding = [System.Text.Encoding]::UTF8
        $env:PYTHONIOENCODING = "utf-8"
        cmd /c chcp 65001 > $null
        
        $args = @("${{ inputs.url }}", "--name", "${{ inputs.name }}", "--target", "win")
        if ("${{ inputs.icon }}" -ne "" -and $env:ICON_PATH) {
          $args += @("--icon", $env:ICON_PATH)
        }
        Write-Host "Running: node cli.js $($args -join ' ')"
        
        # 尝试构建
        $buildSuccess = $false
        $exitCode = 0
        try {
          & node cli.js $args
          $buildSuccess = $true
          $exitCode = $LASTEXITCODE
        } catch {
          Write-Host "Build command failed, but checking if output files were generated anyway..."
          $exitCode = $LASTEXITCODE
        }
        
        # 即使构建报错，也检查是否生成了 MSI 或 .exe 文件
        $outputFound = $false
        
        # 首先检查 MSI 文件
        $msiFiles = Get-ChildItem -Recurse -Filter "*.msi" -ErrorAction SilentlyContinue
        if ($msiFiles) {
          Write-Host "Found MSI files despite error:"
          $msiFiles | ForEach-Object { Write-Host "  $($_.FullName)" }
          # 复制到根目录，使用输入的名称
          $finalMsiName = "${{ inputs.name }}.msi"
          $msiFiles | Select-Object -First 1 | ForEach-Object { Copy-Item $_.FullName -Destination $finalMsiName -Force }
          Write-Host "MSI file copied to: $finalMsiName"
          $outputFound = $true
        } else {
          Write-Host "No MSI files found. Checking for .exe files..."
          # 查找主应用 .exe 文件（排除构建脚本和工具）
          # 主应用 .exe 通常在 target/release 目录下，文件名可能是 productName 或 "app.exe"
          $excludeNames = @("app.exe", "cargo.exe", "rustc.exe", "build_script", "build-script")
          $exeFiles = Get-ChildItem -Recurse -Filter "*.exe" -ErrorAction SilentlyContinue | 
            Where-Object { 
              $exclude = $false
              foreach ($excludeName in $excludeNames) {
                if ($_.Name -like "*$excludeName*") {
                  $exclude = $true
                  break
                }
              }
              -not $exclude -and $_.DirectoryName -like "*\target\release*" -and $_.DirectoryName -notlike "*\build\*"
            } |
            Sort-Object Length -Descending |  # 优先选择较大的文件（主应用通常较大）
            Select-Object -First 1  # 只取第一个匹配的文件
          
          if ($exeFiles) {
            Write-Host "Found main application .exe file:"
            Write-Host "  $($exeFiles.FullName)"
            # 使用输入的名称作为最终文件名
            $finalExeName = "${{ inputs.name }}.exe"
            Copy-Item $exeFiles.FullName -Destination $finalExeName -Force
            Write-Host "Copied to: $finalExeName"
            $outputFound = $true
            Write-Host "Note: Only .exe file was generated (not .msi installer). This is still usable."
          }
        }
        
        # 如果找到了输出文件，即使构建命令失败也视为成功
        if ($outputFound) {
          Write-Host "Build output found. Treating as success despite build command exit code."
          exit 0
        } elseif (-not $buildSuccess) {
          Write-Host "Build failed and no output files found."
          throw "Build failed and no output files found"
        }
      env:
        CI: true
        PYTHONIOENCODING: utf-8

    - name: Upload Windows installer
      uses: actions/upload-artifact@v4
      with:
        name: windows-installer
        path: |
          *.msi
          *.exe
        retention-days: 30
